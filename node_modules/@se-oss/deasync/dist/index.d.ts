import { UnionToIntersection, TupleToUnion } from 'type-fest';

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

declare function runLoopOnce(): void
/**
 * Sleep blocks the current thread for the specified number of milliseconds.
 *
 * @example
 *
 * ```typescript
 * import { sleep } from '@se-oss/deasync';
 *
 * console.log(Date.now(), 'Hello');
 * sleep(1000);
 * console.log(Date.now(), 'World!');
 * ```
 *
 * @param millis The number of milliseconds to sleep for.
*/
declare function sleep(millis: number): void
/**
 * Continuously runs the Node.js event loop while the provided predicate function returns `true`.
 *
 * This function allows executing asynchronous tasks while blocking execution until a condition is met.
 * It repeatedly calls `runLoopOnce`, which processes pending events in the Node.js event loop.
 *
 * @example
 *
 * ```typescript
 * import { sleep } from '@se-oss/deasync';
 * let done = false;
 *
 * setTimeout(() => {
 *   done = true;
 * }, 1000);
 *
 * loopWhile(() => !done);
 * // The task is now complete
 * ```
 *
 * @param env The Node.js environment handle.
 * @param pred A predicate function that returns a boolean. Execution continues while this function returns `true`.
*/
declare function loopWhile(pred: () => boolean): void

type AnyFunc = (...args: any[]) => any;
type CallbackWithResult<TResult> = (err: any, result: TResult, ...rest: any) => void;
type RequiredParameters<T extends AnyFunc> = Required<Parameters<T>>;
type ExtractCallback<T extends AnyFunc> = LastOfUnion<TupleToUnion<Parameters<T>>>;
type LastOfUnion<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never;
/**
 * Converts an asynchronous function into a synchronous one by blocking execution
 * until the callback is called.
 *
 * This function wraps an async function (which follows the Node.js callback pattern)
 * and waits until the provided callback is invoked before returning the result.
 *
 * @example
 *
 * ```typescript
 * import { deasync } from '@se-oss/deasync';
 *
 * function asyncFunction(input: string, callback: (err: any, result: string) => void) {
 *   setTimeout(() => {
 *     callback(null, `Hello, ${input}!`);
 *   }, 1000);
 * }
 *
 * const syncFunction = deasync(asyncFunction);
 * console.log(syncFunction("World")); // Blocks for 1 second, then prints "Hello, World!"
 * ```
 *
 * @template T - The type of the original function.
 * @template Args - The arguments of the original function, excluding the callback.
 * @template Result - The result type extracted from the callback.
 * @param fn - The asynchronous function to be converted.
 * @returns A synchronous version of the provided function.
 */
declare function deasync<T extends AnyFunc, Args extends any[] = RequiredParameters<T> extends [...infer A, any] ? A : never, Result = ExtractCallback<T> extends CallbackWithResult<infer U> ? U : never>(fn: T): (...args: Args) => Result;

export { deasync, loopWhile, runLoopOnce, sleep };
