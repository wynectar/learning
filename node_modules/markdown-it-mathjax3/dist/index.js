//#region rolldown:runtime
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function() {
	return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));

//#endregion
//#region src/mathjax.mts
var mathjax_exports = {};
import * as import_mathxyjax3 from "mathxyjax3";
__reExport(mathjax_exports, import_mathxyjax3);
var init_mathjax = __esm({ "src/mathjax.mts": (() => {}) });

//#endregion
//#region src/index.ts
var require_src = /* @__PURE__ */ __commonJS({ "src/index.ts": ((exports, module) => {
	init_mathjax();
	function isValidDelim(state, pos) {
		let max = state.posMax, can_open = true, can_close = true;
		const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1, nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
		if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57) can_close = false;
		if (nextChar === 32 || nextChar === 9) can_open = false;
		return {
			can_open,
			can_close
		};
	}
	function math_inline(state, silent) {
		if (state.src[state.pos] !== "$") return false;
		let res = isValidDelim(state, state.pos);
		if (!res.can_open) {
			if (!silent) state.pending += "$";
			state.pos += 1;
			return true;
		}
		const start = state.pos + 1;
		let match = start;
		while ((match = state.src.indexOf("$", match)) !== -1) {
			let pos = match - 1;
			while (state.src[pos] === "\\") pos -= 1;
			if ((match - pos) % 2 == 1) break;
			match += 1;
		}
		if (match === -1) {
			if (!silent) state.pending += "$";
			state.pos = start;
			return true;
		}
		if (match - start === 0) {
			if (!silent) state.pending += "$$";
			state.pos = start + 1;
			return true;
		}
		res = isValidDelim(state, match);
		if (!res.can_close) {
			if (!silent) state.pending += "$";
			state.pos = start;
			return true;
		}
		if (!silent) {
			const token = state.push("math_inline", "math", 0);
			token.markup = "$";
			token.content = state.src.slice(start, match);
		}
		state.pos = match + 1;
		return true;
	}
	function math_block(state, start, end, silent) {
		let next, lastPos;
		let found = false, pos = state.bMarks[start] + state.tShift[start], max = state.eMarks[start], lastLine = "";
		if (pos + 2 > max) return false;
		if (state.src.slice(pos, pos + 2) !== "$$") return false;
		pos += 2;
		let firstLine = state.src.slice(pos, max);
		if (silent) return true;
		if (firstLine.trim().slice(-2) === "$$") {
			firstLine = firstLine.trim().slice(0, -2);
			found = true;
		}
		for (next = start; !found;) {
			next++;
			if (next >= end) break;
			pos = state.bMarks[next] + state.tShift[next];
			max = state.eMarks[next];
			if (pos < max && state.tShift[next] < state.blkIndent) break;
			if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
				lastPos = state.src.slice(0, max).lastIndexOf("$$");
				lastLine = state.src.slice(pos, lastPos);
				found = true;
			}
		}
		state.line = next + 1;
		const token = state.push("math_block", "math", 0);
		token.block = true;
		token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
		token.map = [start, state.line];
		token.markup = "$$";
		return true;
	}
	const plugin = (md) => {
		md.inline.ruler.after("escape", "math_inline", math_inline);
		md.block.ruler.after("blockquote", "math_block", math_block, { alt: [
			"paragraph",
			"reference",
			"blockquote",
			"list"
		] });
		md.renderer.rules.math_inline = function(tokens, idx) {
			return mathjax_exports.tex2svgHtml(tokens[idx].content, { display: false });
		};
		md.renderer.rules.math_block = function(tokens, idx) {
			return mathjax_exports.tex2svgHtml(tokens[idx].content, { display: true });
		};
	};
	plugin.default = plugin;
	module.exports = plugin;
}) });

//#endregion
export default require_src();
